# DO NOT EDIT! Generated by protoc-gen-graphql.

type TrackerService_Query {
  """
  Get a tracker by its unique identifier.

  To fetch a tracker by the resource, use `ListTrackers` instead with an
  appropriate filter. Example: `filter = "resource:animes/1245678"`.
  """
  getTracker(input: GetTrackerRequestInput!): Tracker!
  """
  TODO: add documentation about supported filters.
  """
  listTrackers(input: ListTrackersRequestInput!): ListTrackersResponse!
}

type TrackerService_Mutation {
  createTracker(input: CreateTrackerRequestInput!): Tracker!
  updateTracker(input: UpdateTrackerRequestInput!): Tracker!
  deleteTracker(input: DeleteTrackerRequestInput!): Boolean!
  importTracker(input: ImportTrackersRequestInput!): Operation!
  exportTracker(input: ExportTrackersRequestInput!): Operation!
  createActivity(input: CreateActivityRequestInput!): Activity!
  deleteActivity(input: DeleteActivityRequestInput!): Boolean!
}

"""
Activities track the progress of a user related to readable or watchable
resources such as light novel and graphic novel chapters, and anime episodes.

Activities are immutable and store meta information such as when the activity
started, when it ended, from where the progress started and where it stopped.

An example of activities might be a user watching on Netflix the Episode N of
the Anime XYZ from minute 5:47 to minute 15:32 on the 7th of July at 8:35 PM.

In this specific case a Chrome extension might automatically create a new
activity every minute until the user pauses the video or closes the tab.

The information collected allows the service to let the user know when was
the last "checkpoint" recorded, enabling the user to resume the episode at
the correct time on a different platform (i.e. continue from where I left).
Additionally, the information collected is useful to generate histograms and
to idenitify popular scenes within an episode (we all know Pornhub has an
identical feature already).

There is no limit to the number of activities a user might generate and some
activities are automatically registered from Animeshon itself, for example
when a user is reading a graph novel directly on our platform. Activities can
also be repeated multiple times for the same range (e.g. if a user rewatches
the same scene in an episode 5 times).

Whenever an activity is created that marks the end of a resource, its parent
tracker is updated to include it in the list of completed resource.
"""
type Activity {
  """
  The id of the activity.
  """
  name: String!
  """
  The content whose progress is being tracked.
  """
  resource: Consumable
  """
  The platform that the user used to consume the resource.
  """
  platform: String!
  """
  Where the activity started within the resource. This value represents the
  time in seconds within an episode or the page number within a graphic novel
  or light novel chapter.
  """
  from: Int
  """
  Where the activity ended within the resource. This value represents the
  time in seconds within an episode or the page number within a graphic novel
  or light novel chapter.
  """
  to: Int
  """
  When this activity started.
  """
  startTime: DateTime
  """
  When this activity ended.
  """
  endTime: DateTime
}

"""
Activities track the progress of a user related to readable or watchable
resources such as light novel and graphic novel chapters, and anime episodes.

Activities are immutable and store meta information such as when the activity
started, when it ended, from where the progress started and where it stopped.

An example of activities might be a user watching on Netflix the Episode N of
the Anime XYZ from minute 5:47 to minute 15:32 on the 7th of July at 8:35 PM.

In this specific case a Chrome extension might automatically create a new
activity every minute until the user pauses the video or closes the tab.

The information collected allows the service to let the user know when was
the last "checkpoint" recorded, enabling the user to resume the episode at
the correct time on a different platform (i.e. continue from where I left).
Additionally, the information collected is useful to generate histograms and
to idenitify popular scenes within an episode (we all know Pornhub has an
identical feature already).

There is no limit to the number of activities a user might generate and some
activities are automatically registered from Animeshon itself, for example
when a user is reading a graph novel directly on our platform. Activities can
also be repeated multiple times for the same range (e.g. if a user rewatches
the same scene in an episode 5 times).

Whenever an activity is created that marks the end of a resource, its parent
tracker is updated to include it in the list of completed resource.
"""
input ActivityInput {
  """
  The id of the activity.
  """
  name: String!
  """
  The content whose progress is being tracked.
  """
  resource: Consumable
  """
  The platform that the user used to consume the resource.
  """
  platform: String
  """
  Where the activity started within the resource. This value represents the
  time in seconds within an episode or the page number within a graphic novel
  or light novel chapter.
  """
  from: Int
  """
  Where the activity ended within the resource. This value represents the
  time in seconds within an episode or the page number within a graphic novel
  or light novel chapter.
  """
  to: Int
  """
  When this activity started.
  """
  startTime: DateTime
  """
  When this activity ended.
  """
  endTime: DateTime
}

"""
A tracker tracks the progress of one or more users related to releasable
resources such as animes, graphic novels, light novels, and visual novels.

It is important to notice that users cannot `watch` an anime from a technical
perspective but rather they can watch one of its releases such as its pysical
DVD copy or its broadcast on Funimation. Nevertheless, for a better user
experience a releasable content is considered completed whenever a user
watched, played, or read all of its "regular" episodes, chapters, or
releases. This means that "recaps" and "specials" are ultimately ignored.

Animes and novels are easier to track as they have a countable and defined
amount of resources that can be consumed (episodes and chapters). Their
progress is therefore automatically updated whenever a new user activity is
generated.

Visual novels and video games in general do not always have a clear progress
and therefore must be updated manually by the user.

A tracker accounts only for the overall progress on a releasable content,
this means that it won't provide any information about rewatches.

Additionally, trackers can be shared among multiple users thorough audiences,
this is useful whenever a user is, for example, watching an anime together
with a group of friends and wants to keep track of the progress separately
from his/her own personal progress or from the progress on the same resource
with another group of friends (i.e. audience).

The progress of audience trackers affects the personal progress, that is
whenever new resources are consumed by an audience the personal tracker of
each member belonging to that audience will be updated automatically as well.
This behavior makes sense as a group of people  watching the Episode N of the
Anime XYZ also means that each member of the group also watched the episode
and therefore their collective personal progress changed.
"""
type Tracker {
  """
  The id of the tracker.
  """
  name: String!
  """
  The content whose progress is being tracked.
  """
  resource: Trackable
  """
  When the progress started.
  """
  startTime: DateTime
  """
  When the progress ended.
  """
  endTime: DateTime
  """
  The list of completed sub-resources (e.g episodes or chapters).
  """
  completedResources: [Consumable!]
  """
  The percentage of progress from 0 to 100. A null value means the value was
  not manually defined and therefore the percentage should be calculated
  on-the-fly.
  """
  progressPercentage: Float
  """
  The progress state of the tracker.
  """
  state: State!
}

"""
A tracker tracks the progress of one or more users related to releasable
resources such as animes, graphic novels, light novels, and visual novels.

It is important to notice that users cannot `watch` an anime from a technical
perspective but rather they can watch one of its releases such as its pysical
DVD copy or its broadcast on Funimation. Nevertheless, for a better user
experience a releasable content is considered completed whenever a user
watched, played, or read all of its "regular" episodes, chapters, or
releases. This means that "recaps" and "specials" are ultimately ignored.

Animes and novels are easier to track as they have a countable and defined
amount of resources that can be consumed (episodes and chapters). Their
progress is therefore automatically updated whenever a new user activity is
generated.

Visual novels and video games in general do not always have a clear progress
and therefore must be updated manually by the user.

A tracker accounts only for the overall progress on a releasable content,
this means that it won't provide any information about rewatches.

Additionally, trackers can be shared among multiple users thorough audiences,
this is useful whenever a user is, for example, watching an anime together
with a group of friends and wants to keep track of the progress separately
from his/her own personal progress or from the progress on the same resource
with another group of friends (i.e. audience).

The progress of audience trackers affects the personal progress, that is
whenever new resources are consumed by an audience the personal tracker of
each member belonging to that audience will be updated automatically as well.
This behavior makes sense as a group of people  watching the Episode N of the
Anime XYZ also means that each member of the group also watched the episode
and therefore their collective personal progress changed.
"""
input TrackerInput {
  """
  The id of the tracker.
  """
  name: String!
  """
  The content whose progress is being tracked.
  """
  resource: Trackable
  """
  When the progress started.
  """
  startTime: DateTime
  """
  When the progress ended.
  """
  endTime: DateTime
  """
  The list of completed sub-resources (e.g episodes or chapters).
  """
  completedResources: [Consumable!]
  """
  The percentage of progress from 0 to 100. A null value means the value was
  not manually defined and therefore the percentage should be calculated
  on-the-fly.
  """
  progressPercentage: Float
  """
  The progress state of the tracker.
  """
  state: State
}

"""
TODO: this is represented as a group in authorization.
TODO: who should be the owner of an audience? the user who created it?
"""
type Audience {
  """
  The id of the audience.
  """
  name: String!
  """
  The members of this audience.
  """
  members: [String!]!
}

input GetTrackerRequestInput {
  """
  The name of the tracker to retrieve.
  """
  name: String!
}

input ListTrackersRequestInput {
  """
  The user this tracker belongs to.
  """
  parent: String!
  """
  If unspecified, server will pick an appropriate default.
  """
  pageSize: Int
  """
  The value returned from the previous call.
  """
  pageToken: String
  """
  A filter to be applied to results.
  """
  filter: String
}

type ListTrackersResponse {
  """
  The list of trackers.
  """
  trackers: [Tracker!]!
  """
  A token to retrieve next page of results.
  """
  nextPageToken: String!
}

input CreateTrackerRequestInput {
  """
  The parent this tracker belongs to.
  """
  parent: String!
  """
  The tracker to create.
  """
  tracker: TrackerInput!
}

input UpdateTrackerRequestInput {
  """
  The tracker to update.
  """
  tracker: TrackerInput!
  """
  The field mask to determine which fields are to be updated. If empty, the
  server will assume all fields are to be updated.
  """
  updateMask: FieldMaskInput
}

input DeleteTrackerRequestInput {
  """
  The name of the tracker to delete.
  """
  name: String!
}

input CreateActivityRequestInput {
  """
  The parent this tracker belongs to.
  """
  parent: String!
  """
  The activity to create.
  """
  activity: ActivityInput!
}

input DeleteActivityRequestInput {
  """
  The name of the activity to delete.
  """
  name: String!
}

"""
Selecting what provider we want to import from
"""
input ImportTrackersRequestInput {
  parent: String!
  provider: Provider
}

"""
Selecting what provider we want to export to
"""
input ExportTrackersRequestInput {
  parent: String!
  provider: Provider
}

"""
Represents the metadata of the long-running operation.
"""
type OperationMetadata {
  """
  Output only. The time the operation was created.
  """
  createTime: DateTime
  """
  Output only. The time the operation finished running.
  """
  endTime: DateTime
  """
  Output only. Server-defined resource path for the target of the operation.
  """
  target: String!
  """
  Output only. Name of the verb executed by the operation.
  """
  verb: String!
  """
  Output only. Human-readable status of the operation, if any.
  """
  statusMessage: String!
  """
  Output only. Identifies whether the user has requested cancellation
  of the operation. Operations that have successfully been cancelled
  have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
  corresponding to `Code.CANCELLED`.
  """
  requestedCancellation: Boolean!
  """
  Output only. API version used to start the operation.
  """
  apiVersion: String!
  """
  Output only.
  """
  progressPercentage: Int!
}

"""
TODO(christian-roggia): this is a workaround to solve the issue of GAPIC
CLI where broken code is generated if google.protobuf.Empty is used in the
response_type of longrunning operations.
"""
type ImportTrackersResponse {
  _empty: Boolean
}

type ExportTrackersResponse {
  _empty: Boolean
}

enum State {
  STATE_UNSPECIFIED
  """
  The consumption of the media is still in progress.
  """
  IN_PROGRESS
  """
  The consumption of the media has been completed.
  """
  COMPLETED
  """
  The consumption of the media is on hold.
  """
  ON_HOLD
}

enum Provider {
  PROVIDER_UNSPECIFIED
  MYANIMELIST
  MANGADEX
  ANILIST
  ANIDB
  MANGAUPDATES
  VNDB
}
